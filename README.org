#+TITLE: CUDA Lens Test

Here we try to accellerate plummer lenses with cuda.

* Comparison sample GRALE2

#+CAPTION: Comparison, no intensity in cuda example
[[./multiplane_comparison.png]]

* Building

** Default

   #+BEGIN_SRC bash
   cmake CMakeLists.txt
   make
   #+END_SRC

** Debug

   #+BEGIN_SRC bash
   cmake CMakeLists.txt -DCMAKE_BUILD_TYPE=DEBUG
   make
   #+END_SRC

*** Running tests (CPU)

	#+BEGIN_SRC bash
	./bin/unit_tests
	#+END_SRC

*** Running tests (CUDA)

	#+BEGIN_SRC bash
	./bin/cu_unit_tests
	#+END_SRC

* Example	

  For the example there is a notebook that generates some test
  parameters. A file generated by this notebook can be used as a test
  file.

* API

  To use this library see =example/example.cpp=.
  
** Documentation
   
   You can run =Doxygen= to generate the documentation. 

* Implementation                                                   :noexport:

A short explanation of this implementation.

** Lenses
   
   We implement these lenses both as =__host__= and =__device__=
   functions to make unit testing possible on machines without CUDA
   capable devices. The unit tests contain examples on how to use
   these structures.
   
   For the cuda version we split each point into an x and y vector,
   this makes loading / storing from global memory a bit
   faster[fn:1]. For the lenses each thread needs the same block of
   memory, so we try to use the read-only cache[fn:2]. The biggest
   performance problem encountered was a high local memory usage
   because functions were defined in seperate c++/cu files. By placing
   the function body for small functions inside the headers, the
   compiler can inline them, giving a very strong performance
   increase. We use a lot more registers, which does hurt
   performance. Luckily for bigger datasets we can limit the amount of
   registers for maximum occupancy and an actual increase in
   performance[fn:3]. With all this there's also a small improvement
   when increasing blocksize (but don't go too high, need to tweak for
   data, 256 seems good).

[fn:1] Memory Coalescing: https://devblogs.nvidia.com/how-access-global-memory-efficiently-cuda-c-kernels/
[fn:2] RO cache: https://docs.nvidia.com/cuda/kepler-tuning-guide/index.html#read-only-data-cache
[fn:3] Spilling: https://developer.download.nvidia.com/CUDA/training/register_spilling.pdf   

*** Builders

	We use =builder= classes to "build" our multiplane, these classes
	also handle device memory related functions. Currently they also
	free those memory allocations, so keep them alive. In the future
	this may be moved into the lens objects themself, depends on how
	we choose to do memory management.

*** Plummer lens

	Simple lens model, we don't do a lot of special things here. This
	class has a lot of extra variables but removing them seems to
	significantly worsen performance. For floating point calculations
	we also use a scaling factor to minimize error with very small
	values.
    
	$$ \Sigma(\vec{\theta}) = \frac{M}{\pi
	D_d^2}\frac{\theta_P^2}{(\theta^2 + \theta_P^2)^2} $$

	$$ \vec{\hat{\alpha}}(\vec{\theta}) = \frac{4GM}{c^2
	D_d}\frac{\vec{\theta}}{\theta^2+\theta_P^2} $$

	$$\vec{\beta} = \vec{\theta} - \frac{D_{ds}}{D_s}\frac{4GM}{c^2
	D_d}\frac{\vec{\theta}} {\theta^2+\theta_P^2} $$

*** Composite lens

	Unfortunately we can't really use inheritance, but some functions
	are very similar to the Plummer lens. We prefer having constant
	size objects for copying to and from a gpu.

	$$ \vec{\hat{\alpha}}(\vec{\theta}) = \sum_i^N
	\vec{\hat{\alpha}}_i(\vec{\theta})$$
	
	Use =getCuLens()= to get a lens for use with cuda instead of
	=getLens()=. We use a builder class because we need to copy a
	unknown vector to a device.

*** Multiplane
	
	We use a similar builder model to create a multiplane object. The
	=getLens()= functions also calls a =prepare()= function to sort
	planes and calculate angular diameter distances for redshifts with
	each object. These values =Ds= and =Dds= are set in the plummer
	class, for source planes they are calculated for the last lens but
	put in the source class.
	
	#+CAPTION: traceTheta pseudocode
	#+BEGIN_SRC 
	Draw each source plane with redshift < lens[0].redshift directly
	for each lens {
	    for each source with redshift before next lens {
		    draw source with current lens
			s_theta = currentlens.getBeta(theta, src.Ds, src.Dds)
			if hit return pixel(s_theta)
		}
		theta = currentlens.getBeta(theta)
	}
	Draw remaining source planes with last lens
	#+END_SRC
